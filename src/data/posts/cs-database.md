---
title: "알면좋은 데이터베이스"
date: "2024-03-22"
author: "Jin"
description: "개발자가 알면좋은 데이터베이스에 대한 개념"
category: "Computer Science"
tags: ["Database", "CS", "SQL", "RDBMS", "NoSQL"]
series: "cs-series"
seriesOrder: 3
imageUrl: "/next.svg"
---

## 데이터베이스란 무엇인가?

### 데이터베이스의 정의와 필요성

데이터베이스는 조직화된 데이터의 집합체입니다. 단순한 파일 시스템과 달리, 데이터베이스는 구조화된 형태로 데이터를 저장하고 효율적으로 관리할 수 있게 해줍니다.

💡 **Point**
- 데이터의 중복 최소화
- 데이터 일관성 보장
- 동시 접근 제어
- 데이터 무결성 유지

### 데이터베이스의 종류

#### 1. 관계형 데이터베이스 (RDBMS)
- MySQL, PostgreSQL, Oracle
- 데이터를 테이블 형태로 저장
- SQL을 사용하여 데이터 조작

#### 2. NoSQL 데이터베이스
- MongoDB, Redis, Cassandra
- 비정형 데이터 저장에 적합
- 높은 확장성과 유연성

## 핵심 개념

### 1. ACID 속성

| 속성 | 설명 |
|------|------|
| Atomicity (원자성) | 트랜잭션의 모든 연산이 성공하거나 모두 실패 |
| Consistency (일관성) | 트랜잭션 전후의 데이터 일관성 보장 |
| Isolation (격리성) | 동시 실행되는 트랜잭션들이 서로 영향을 주지 않음 |
| Durability (지속성) | 완료된 트랜잭션의 결과는 영구적으로 보존 |

### 2. 정규화 (Normalization)

데이터베이스 설계 시 중복을 최소화하고 데이터 일관성을 보장하기 위한 과정입니다.

```ascii
제1정규형 (1NF)
    ↓
제2정규형 (2NF)
    ↓
제3정규형 (3NF)
    ↓
BCNF
```

### 3. 인덱스 (Index)

```sql
-- 인덱스 생성 예시
CREATE INDEX idx_user_email ON users(email);
```

💡 **실무 최적화 팁**
- 자주 조회되는 컬럼에 인덱스 생성
- 복합 인덱스는 선택도가 높은 컬럼을 앞에 배치
- 불필요한 인덱스는 제거하여 성능 저하 방지

## 실무 응용

### 1. 데이터베이스 설계 패턴

```ascii
[사용자 테이블]
    ↓
[주문 테이블] → [상품 테이블]
    ↓
[결제 테이블]
```

### 2. 성능 최적화

#### 쿼리 최적화 예시
```sql
-- 비효율적인 쿼리
SELECT * FROM users WHERE email LIKE '%@gmail.com';

-- 최적화된 쿼리
SELECT * FROM users WHERE email LIKE '@gmail.com%';
```

💡 **LIKE 연산자와 와일드카드 위치의 중요성**

1. **비효율적인 쿼리가 느린 이유**:
   - `%`를 앞에 사용하면 인덱스를 활용할 수 없음
   - 테이블 전체를 스캔(Full Table Scan)해야 함
   - 데이터가 많을수록 성능이 급격히 저하

2. **최적화된 쿼리의 장점**:
   - `%`를 뒤에만 사용하면 인덱스 활용 가능
   - 이메일의 시작 부분으로 인덱스 검색 가능
   - 부분 범위 스캔으로 성능 향상

예시 성능 비교:
| 쿼리 유형 | 100만 건 기준 실행 시간 | 인덱스 사용 여부 |
|----------|-------------------|--------------|
| `LIKE '%@gmail.com'` | ~2-3초 | 사용 불가 |
| `LIKE '@gmail.com%'` | ~0.1초 | 사용 가능 |

### 3. 트러블슈팅 가이드

| 문제 상황 | 해결 방안 |
|----------|-----------|
| 느린 쿼리 | - EXPLAIN 분석 <br> - 인덱스 최적화 <br> - 쿼리 재작성 |
| 데드락 | - 트랜잭션 범위 축소 <br> - 락 획득 순서 통일 |
| 커넥션 풀 고갈 | - 커넥션 누수 확인 <br> - 풀 사이즈 조정 |

## 면접 대비 핵심 질문

### 1. 인덱스의 작동 원리와 장단점은?

**모범답안**:
"인덱스는 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다.

#### 작동 원리
- **B-Tree 구조**를 기반으로 동작하며, 이진 탐색이 가능한 균형 트리 구조입니다
- 루트 노드, 브랜치 노드, 리프 노드로 구성되어 있습니다
- 데이터는 정렬된 상태로 유지되며, 로그 시간 복잡도(O(log n))로 검색이 가능합니다

> B-Tree란?

> B-Tree는 데이터베이스 인덱스와 파일 시스템에서 널리 사용되는 자료구조입니다. 이 구조는 대량의 데이터를 효율적으로 관리하고 검색할 수 있도록 설계되었습니다.

> B-Tree의 특징

> - **균형 트리 구조**: 모든 리프 노드가 동일한 깊이에 위치하여, 트리가 항상 균형을 유지합니다. 이는 검색, 삽입, 삭제 시 일관된 성능을 보장합니다.
> - **빠른 검색**: 로그 시간 복잡도(O(log n))로 검색이 가능하여, 대량의 데이터에서도 효율적입니다.
> - **디스크 I/O 최적화**: 노드가 디스크 블록 크기에 맞춰져 있어, 디스크 접근 횟수를 최소화합니다.

B-Tree는 이러한 특성 덕분에 데이터베이스 인덱스의 구현에 적합하며, 특히 대량의 데이터를 다루는 시스템에서 그 효율성을 발휘합니다.

#### 장점
- 데이터 검색 속도가 획기적으로 향상됩니다
- WHERE, JOIN, ORDER BY 절의 성능을 개선합니다
- 유니크한 값을 보장할 수 있습니다

#### 단점
- 추가적인 저장 공간이 필요합니다 (보통 원본 데이터의 10% 정도)
- INSERT, UPDATE, DELETE 시 인덱스도 함께 수정되어 성능이 저하될 수 있습니다
- 잘못 설계된 인덱스는 오히려 성능을 저하시킬 수 있습니다"

### 2. 트랜잭션 격리 수준이란?

**모범답안**:
"트랜잭션 격리 수준은 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 수준입니다.

#### READ UNCOMMITTED (레벨 0)
- 가장 낮은 격리 수준
- Dirty Read, Non-Repeatable Read, Phantom Read 발생 가능
- 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있음

#### READ COMMITTED (레벨 1)
- 대부분의 DBMS가 기본으로 사용하는 수준
- Dirty Read 방지
- Non-Repeatable Read, Phantom Read 발생 가능
- 커밋된 데이터만 읽을 수 있음

#### REPEATABLE READ (레벨 2)
- MySQL InnoDB의 기본 격리 수준
- Dirty Read, Non-Repeatable Read 방지
- Phantom Read 발생 가능
- 트랜잭션이 시작되기 전의 데이터를 보장

#### SERIALIZABLE (레벨 3)
- 가장 높은 격리 수준
- 모든 문제 방지 (Dirty Read, Non-Repeatable Read, Phantom Read)
- 완벽한 읽기 일관성 제공
- 성능 저하가 심함

💡 **실무 팁**: 대부분의 경우 READ COMMITTED나 REPEATABLE READ를 사용하며, 격리 수준이 높을수록 동시성이 떨어지므로 서비스의 특성에 맞게 적절한 수준을 선택해야 합니다."

## 마무리

### 추가 학습 자료
- [공식 MySQL 문서](https://dev.mysql.com/doc/)
- [PostgreSQL 튜토리얼](https://www.postgresql.org/docs/)
- [MongoDB 대학](https://university.mongodb.com/)

### 실습 과제
1. 간단한 블로그 시스템 DB 설계하기
2. 인덱스 성능 테스트해보기
3. 다양한 조인 쿼리 작성해보기
```

이 글은 다음과 같은 특징을 가지고 있습니다:

1. **체계적인 구조**:
   - 기본 개념부터 심화 내용까지 단계적 구성
   - 시각적 요소(표, 다이어그램)를 활용한 설명
   - 실무 적용 사례와 문제 해결 방법 포함

2. **실용적인 내용**:
   - 실제 개발 현장에서 필요한 내용 중심
   - 구체적인 코드 예시와 최적화 팁 제공
   - 트러블슈팅 가이드 포함

3. **학습 효과 극대화**:
   - 핵심 포인트 강조
   - 면접 대비 질문 정리
   - 추가 학습 자료와 실습 과제 제공
