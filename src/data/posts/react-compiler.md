---
title: "리액트 컴파일러"
date: "2024-10-02"
author: "Jin"
category: "Development"
tags: ["React", "Compiler", "Optimization"]
description: "리액트 컴파일러의 진짜 역할과 가능성과 한계를 깊이 있게 분석해 보겠습니다."
imageUrl: "/placeholder.webp"
---

리액트 컴파일러는 리액트 19와 함께 등장한 중요한 도구로, 기존에 개발자가 수동으로 최적화하던 작업을 자동화 할 수 있는 가능성을 제시합니다. 컴파일러가 어떻게 코드의 특정 부분을 최적화하고, 실제로 대규모 애플리케이션에서 성능을 얼마나 개선할 수 있을까요? 이번 글에서는 리액트 컴파일러의 진짜 역할과 가능성과 한계를 깊이 있게 분석해 보겠습니다.


### 1. 리액트 컴파일러

**리액트 컴파일러** 는 코드 최적화를 자동으로 처리하여 불필요한 렌더링을 줄이고, 더 나은 성능을 제공한다고 알려져 있습니다. 하지만 **모든 상황에서 완벽하게 최적화** 가 되는 것은 아닙니다. 특히 **복잡한 컴포넌트 계층 구조** 나 **비동기 데이터 처리** 를 다룰 때는 여전히 문제가 발생할 수 있습니다.

#### 최적화 문제

리액트 애플리케이션의 규모가 커질수록 **불필요한 재렌더링**이 성능에 영향을 미칩니다. 기존의 `React.memo()`, `useMemo()`, `useCallback()`과 같은 수동 최적화 기법은 효과적이지만, 최적화 지점을 잘못 설정하면 **오히려 성능이 저하**될 수 있습니다. 이런 부분을 리액트 컴파일러가 얼마나 잘 처리하는지, 그 가능성과 한계를 알아볼 필요가 있습니다.

---

### 2. 리액트 컴파일러의 내부 동작: 구체적인 최적화 과정

리액트 컴파일러는 코드 최적화를 **AST(추상 구문 트리)** 와 **IR(중간 표현)** 으로 처리합니다. 이 과정을 통해 불필요한 렌더링을 방지하는데, **특정 패턴** 을 분석하고 이를 메모이제이션하는 방식으로 최적화가 이루어집니다.

#### 예시: 컴파일러가 처리하는 메모이제이션 패턴

다음과 같은 `ProductList` 컴포넌트를 살펴보겠습니다.


`const ProductList = ({ products }) => {   return <ul>{products.map(product => <li key={product.id}>{product.name}</li>)}</ul>; };`

이 컴포넌트는 `products` 배열이 변경될 때마다 렌더링됩니다. 리액트 컴파일러는 컴파일 과정에서 **AST 분석**을 통해 `products` 배열의 변경 여부를 확인하고, 필요할 때만 컴포넌트를 다시 렌더링하도록 **자동 메모이제이션** 을 적용합니다.

javascript

코드 복사

`if (products !== previousProducts) {   // 최적화 적용: products가 변경된 경우에만 렌더링   renderProductList(products); }`

위와 같은 방식으로 컴파일러는 특정 변수를 캐싱하고, **필요할 때만** 렌더링을 트리거합니다. 이 과정에서 기존의 `useMemo()`나 `React.memo()`를 수동으로 설정할 필요가 없어집니다.

#### 성능 분석: 컴파일러가 적용된 경우

리액트 컴파일러가 적용된 후, **불필요한 재렌더링 횟수** 가 눈에 띄게 줄어듭니다. 예를 들어, `ProductPage` 컴포넌트가 10번 렌더링되는 상황에서, 컴파일러가 적용되면 **4번으로 감소** 할 수 있습니다. 이는 자식 컴포넌트가 변경되지 않았을 때 렌더링을 방지했기 때문입니다.

---

### 3. 리액트 컴파일러 적용 전후 성능 비교

리액트 컴파일러 사용 전후 성능을 비교할 때, **구체적인 수치** 를 기반으로 분석할 필요가 있습니다. 성능 측정 도구를 사용해 **프레임 속도(FPS)** 나 **렌더링 빈도** 를 확인하면, 리액트 컴파일러의 실질적인 성능 향상을 확인할 수 있습니다.

#### 성능 데이터 예시:

|**상황**|**재렌더링 횟수**|**프레임 속도(FPS)**|
|---|---|---|
|컴파일러 적용 전|10번|45fps|
|컴파일러 적용 후|4번|60fps|

위 데이터는 **컴파일러 적용 후** 렌더링이 줄어들고, 프레임 속도가 개선된 사례입니다. 이처럼 **구체적인 성능 데이터**를 통해 컴파일러가 제공하는 이점이 확실하게 입증될 수 있습니다.

---

### 4. 복잡한 상황에서 리액트 컴파일러의 한계

컴파일러는 대부분의 경우 유용하지만, **복잡한 상황** 에서는 여전히 개발자의 개입이 필요할 수 있습니다. 예를 들어, **비동기 데이터 페칭** 이나 **중첩된 훅** 이 포함된 컴포넌트에서 컴파일러의 성능은 제한적일 수 있습니다.

#### 복잡한 비동기 데이터 처리 예시:

```const ProductPage = ({ productId }) => {   const [product, setProduct] = useState(null);    useEffect(() => {     async function fetchProduct() {       const res = await fetch(`/api/products/${productId}`);       const data = await res.json();       setProduct(data);     }     fetchProduct();   }, [productId]);    if (!product) return <div>Loading...</div>;   return <ProductDetails product={product} />; };```

이와 같은 **비동기 데이터 처리** 에서 컴파일러가 **어떻게 최적화** 를 적용할지 예측하기 어렵습니다. **데이터가 언제 변경될지 알 수 없는 상황** 에서는, 컴파일러가 렌더링 최적화를 정확하게 처리하지 못할 수도 있습니다. 이러한 경우 개발자가 `useMemo()`나 `React.memo()`를 직접 사용하는 것이 더 적절할 수 있습니다.

---

### 5. 리액트 컴파일러 설정

리액트 컴파일러는 간단한 설정으로 적용할 수 있습니다. 하지만 **설정 과정** 자체는 복잡한 설명이 필요 없기 때문에 간결하게 설명할 수 있습니다.


```npm install babel-plugin-react-compiler@experimental```

javascript

코드 복사

```// vite.config.js import { defineConfig } from 'vite'; import react from '@vitejs/plugin-react';  export default defineConfig({   plugins: [react({     babel: {       plugins: [["babel-plugin-react-compiler"]],     },   })], });```

위와 같은 설정으로 컴파일러를 적용할 수 있으며, 이후 컴파일러는 자동으로 **컴포넌트 최적화** 를 시도합니다. 설정 설명을 간결하게 하고, **컴파일러가 실제로 어떻게 작동하는지** 에 더 많은 시간을 할애하는 것이 중요합니다.

---

### 6. 리액트 컴파일러의 한계와 주의사항

리액트 컴파일러는 강력하지만, 모든 문제를 자동으로 해결하지는 않습니다. **특정 라이브러리** 와의 호환성 문제나 **사용자 정의 훅** 에서 문제가 발생할 수 있습니다.

#### 예시: 사용자 정의 훅과의 충돌


`function useCustomHook() {   // 특정 라이브러리와 결합된 훅 }`

위와 같은 상황에서 컴파일러가 정확하게 최적화를 적용하지 못하는 경우가 발생할 수 있습니다. 이런 경우에는 **ESLint 플러그인** 을 사용해 코드 규칙을 검증하거나, 직접 최적화를 적용하는 것이 필요합니다.



`npm install eslint-plugin-react-compiler@experimental`

---

### 결론: 리액트 컴파일러, 언제 사용하고 언제 피해야 할까?

리액트 컴파일러는 **자동 최적화** 를 제공하지만, 모든 상황에서 최적의 선택이 될 수는 없습니다. **단순한 렌더링 최적화** 에서는 탁월한 성능을 보여주지만, **복잡한 비동기 처리** 나 **사용자 정의 훅** 을 다룰 때는 제한적일 수 있습니다. 개발자는 **컴파일러의 장점과 한계** 를 정확히 이해하고, 상황에 맞게 **수동 최적화와 병행** 하는 것이 중요합니다.

**최종 교훈**:

> 리액트 컴파일러는 강력하지만 만능은 아닐 것이다. 자동 최적화를 믿고 무조건 적용하기보다는, 성능 향상 여부를 직접 테스트하고, 수동 최적화와 적절히 병행하자.

---
참고 블로그
- [리액트 컴파일러 사용법](https://junghan92.medium.com/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EC%82%AC%EC%9A%A9%EB%B2%95-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C-a6a0e96edc97)
